# 缓存

## 缓存读写模式

### Cache Aside Pattern

- 读的时候先读缓存，如果读不到再读数据库，并且放入缓存，然后返回

- 更新的时候先更新数据库再删除缓存

### Read/Write Through Pattern

- 应用程序只操作缓存，缓存中间件负责跟数据库交互。读缓存，缓存没有，由缓存回源数据库并将数据写入缓存。写缓存，由缓存将数据写入数据库（guava cache）

### Write Behind Caching Pattern

- 应用程序只跟缓存交互，不直接操作数据库，缓存中的数据通过异步的方式同步到数据库，有可能会丢数据

## 缓存更新策略

- 设置redis的淘汰策略，LRU，LFU

- 设置key的TTL

- 更新数据库时删除缓存（延时双删）

- 异步将数据库的数据刷入缓存

## 缓存数据库一致性

- 正常情况下采用Cache Aside Pattern模式即可

- 高并发下采用延时双删策略，采用Cache Aside Pattern模式删除缓存后2秒再次删除缓存，避免高并发下读取到旧数据

- 设置缓存过期时间，保证缓存数据最终一致性

- 缓存删除失败做日志记录，特殊处理

## 分布式锁

### Redis实现分布式锁

#### 方案

- set(NX,EX)

- setnx()

- lua脚本

#### 问题

- 单机无法实现高可用，分布式环境，由于Redis是一个AP模型，主从没法保证强一致性，高并发下有可能会导致锁的重复获得

- 锁无法续租

### 分布式锁方案对比

- Redis是AP模型，分布式环境无法保证强一致性。Zookeeper和etcd实现了强一致性算法

## 乐观锁

- Redis的watch机制

## 架构设计思路

![](/Users/dujunchen/coding/github/BackEndCore/Cache/assets/2022-05-13-15-47-17-image.png)

### 多层次

#### Nginx缓存

- 不经常更新

#### Tomcat本地缓存（JVM缓存）

- 高并发

- 不要求实时一致

- 占用内存不高

- 不经常变化

#### Redis分布式缓存

### 数据类型支持，是否需要持久化

### 集群部署

### 缓存数据结构设计

### 权衡服务可用性和一致性

### 缓存命中率

### 缓存预热

### 性能指标监控

## 常见问题

### 缓存穿透

#### 原因

- 由于访问缓存中**不存在的key**，导致大量请求直接访问数据库

#### 解决

- 布隆过滤器

### 缓存雪崩

#### 原因

- 由于**同一时间大量的key过期失效**导致大量请求直接访问数据库

#### 解决

- 分散key的有效期

- 增加本地缓存，牺牲一定的数据一致性

### 缓存击穿

#### 原因

- 由于**某一个或者一些高热点key过期失效**导致大量请求直接访问数据库

#### 解决

- 使用分布式锁

### 

### 大Key

- String类型的大key尽量使用MongoDB存储，如果一定要存储，单独存储

- 将hash、list、set等中存储的过大过多的元素拆分成多个小的kv

- 删除kv时不要使用del，因为会阻塞

### 热Key

#### 解决

- 增加本地缓存

- 每个Redis节点上都备份热Key，将负载分摊到每一个节点上

- 热点数据访问做熔断限流保护措施

### 并发竞争

#### 原因

- 多个Redis客户端同时对同一个key进行set操作，会导致set的顺序随机

#### 解决

- 使用分布式锁+时间戳控制执行顺序

- 使用消息队列

### 单线程Redis为什么这么快

- Redis的操作都在内存中，只要合理设置Redis的maxmemory和淘汰策略，正常情况下不会出现内存和硬盘的swap

- 单线程没有锁开销，没有多线程切换开销

- 数据结构设计充分考虑了性能优化

- 使用了IO多路复用技术的Reactor模式
