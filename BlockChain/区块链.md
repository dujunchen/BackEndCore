# 区块链
## 比特币
### 密码学原理
#### 哈希函数

- collision resistance 
哈希碰撞客观上存在，但是没有高效的办法可以人为制造哈希碰撞，理论上可以使用暴力破解。

- hiding
哈希函数计算是单向，不可逆的。理论上可以使用暴力破解。

这两个特点可以实现密封信封的功能。

比特币中使用的哈希函数需要满足puzzle frendly的性质，要求生成的哈希结果不可预测，只能通过暴力破解方式。

#### 签名

- 非对称加密
用来解决对称加密分发密钥不方便的问题。使用接收方的公钥加密，接收方接收到数据后使用私钥解密。公钥（银行卡账户）是公开的，不怕被窃听，私钥（相当于银行卡账户的密码）只需要保存在接收方本地，并不需要在网络上传输。

- 比特币系统开户
本地生成一对公钥私钥。生成公钥私钥的目的是为了签名。发送消息方使用私钥对消息签名，然后其他节点使用公钥验签。
 
### 数据结构
 
 - 比特币中的区块链和普通链表的主要区别在于使用哈希指针代替传统指针。使用哈希指针连接各个区块形成链表，形成区块链。
 - Merkle树和二叉树的区别在于使用哈希指针代替传统指针。每个区块中的交易采用Merkle树结构存储。所有交易生成的root hash值保存在区块头部，但是区块头部并不会保存具体交易内容。
 - 区块有区块头和区块体组成。区块头包含
 
 

### 分布式共识协议
#### 分布式理论

- FLP
- CAP
- Paxos

#### 比特币中的分布式共识

- 区块链的目的是为了在互不信任的实体之间建立共识。
- 普通的投票机制会遭遇sybil attack问题。比特币采用是根据工作量投票机制来避免这一问题。
- 最长合法链原则（分叉攻击） 

### 比特币系统的实现

#### 比特币和出矿奖励

- 初始每出一个区块可以获得50BTC，之后每21万个区块减半，大约需要4年时间。这是获取新的比特币的唯一途径。
- 比特币总量=21万\*50\*（1+1/2+1/4+...）=2100万个


#### UTXO

- 全节点需要维护一个UTXO数据结构，来记录未花费的交易输出。
- 比特币系统中要知道一个账户的余额，只能通过UTXO推算得出。
- UTXO设计的目的是为了快速校验新交易的合法性，以防止double spending问题。

#### 交易

- 比特币系统中的交易分为铸币交易和普通交易。铸币交易没有交易输入，是产生新的比特币的唯一途径。普通交易每一个输入使用的BTC都需要说明是由哪一个之前的交易中的第几个输出产生的。
- 输入减去输出的差额是作为交易费支付给矿工。
- 输入输出都是通过脚本方式给定的。将当前交易的输入脚本和上一个交易的输出脚本拼接后（交叉）执行用来校验交易的合法性。

#### 脚本

比特币脚本语言基于堆栈结构。不具有图灵完备，不支持循环操作。

- P2PK
最简单的形式。
- P2PKH
使用最多的形式。
- P2SH
主要用于多重签名。
- Proof of Burn
脚本以RETURN开头，不论input 脚本如何设计，执行到RETURN都会直接返回，不会往下执行，所以这个输出脚本对应的比特币永远不会被花费。可以用来永久保存一些数据到区块链。输出脚本在校验当前交易合法性的时候是不会被执行的，只有当下一个交易需要花费该输出时才会执行，这样，该脚本才得以执行。

#### 挖矿

- progress free 
具有无记忆性。将来还需要挖矿的时间跟过去已经挖矿的时间是没有关系的。主要用来保证挖矿的公平性，否则算力强的矿工就会比算力弱的矿工有优势。
- 比特币系统的安全性是通过挖矿机制来保证的。只要超过一半的计算力掌握在诚实人手中，比特币系统安全性就可以得到保证。
- 比特币系统默认每十分钟出一个区块。如果区块被挖出的速度越快，区块链分叉的概率会更高，这样诚实人的算力会被分散，系统会更加容易被分叉攻击（51% attack）。
- 比特币系统每2016个区块需要调整一下挖矿难度，大约需要2周时间。难度调整公式：next_difficulty=previous_difficulty * (2 weeks) / (time to mine last 2016 blocks)
- selfish mining
事先挖好一系列区块，但是不公开。
 
#### 矿池及利益分成

- 矿主和矿工  
矿主负责除了Hash运算以外其他工作，矿工只负责Hash运算工作。矿池的收益按照每个矿工的工作量分成。
- 矿池的出现使得矿工的收入变的稳定，减轻矿工的负担。
- 大型矿池使得51% sttack变得更加容易，因为矿工不需要自己拥有51%算力，只需要能动员51%算力即可。

#### 分叉

- state fork  
对区块链中当前状态出现分歧导致的分叉。
- protocol fork  
  - 因为比特币协议的不同意见导致的分叉。
  - 根据协议内容不同可以分为硬分叉和软分叉。
     - soft fork
     只需要半数以上算力的节点更新软件，就不会出现永久性分叉，只会出现临时性分叉。典型例子如coinbase域和P2SH。
     - hard fork
     必须系统中所有节点都更新软件，才不会出现永久分叉。


#### 挖矿中存在的问题



 
### 比特币网络

- 应用层：比特币区块链
- 网络层：P2P Overlay Network，所有节点都是平等的，相互之间采用TCP通信。
- 每一个节点会维护一个邻居节点集合，消息在网络中采用flooding方式传播。邻居节点选举随机的，不考虑底层网络拓扑结构。
- 设计原则：简单、健壮，但是牺牲了高效。

### 比特币的安全

- 比特币系统的安全主要有两部分来做保证，第一是密码学的保证，第二是共识机制。
- 提高比特币的匿名性
  - 网络层
  采用洋蔥路由（Onion routing）保证。
  - 应用层  
  coin mixing  
  零知识证明 
  零币、零钞
  
## 以太坊([原理](https://ethfans.org/posts/ethereum-explained-merkle-trees-world-state-transactions-and-more))

### 账户

- 以太坊是基于账户的系统。比特币和以太坊都是交易驱动的状态机。
- 账户地址160位，20个字节，40个16进制表示。分为外部账户和智能合约账户。我们用来互相收发以太币、部署智能合约的账户就是外部账户，而部署智能合约时自动生成的账户则是合约账户。交易只能从外部账户发起。外部账户属性有balance、nonce，合约账户有balance、nonce、code、storage。

### 状态树

- Merkle Patricia Trie（MPT）
- 对状态树的修改会新建一个树，而会保留历史记录。原因是为了回滚交易，因为以太坊中的智能合约图灵完备，功能比较复杂，无法从结果反推回到执行之前的状态。
- 多个状态树之间会共享一些数据，只有改变交易状态的节点需要新建一个分支，其余的直接引用其他节点即可。

### 交易树和收据树

- 和状态树的区别：交易树和收据树只包含当前这个交易相关的信息，而状态树需要包含系统中所有账户的状态信息。另外和状态树不同，交易树和收据树的节点之间不会共享节点数据。
- 每个交易结束后会得到一个收据。交易列表长度应该等于收据列表长度。
- 布隆过滤器

### 交易 [字段解释](http://blog.liuhongnan.com/2018/02/02/Ethereum%E4%BA%A4%E6%98%93%E8%AF%A6%E8%A7%A3/)
#### 分类

- 以太坊中的交易分为三类：
  - 转账
  - 创建部署智能合约
  - 调用智能合约

#### 交易执行流程（[以太坊交易生命周期](https://ethfans.org/posts/life-cycle-of-an-ethereum-transaction)）

- 构建原始交易对象(RawTransaction)。
- 使用交易账户的私钥对原始交易对象进行签名。
- 签署过后的交易会提交至以太坊节点。然后节点会验证已签名的交易，确保它是由交易账户签署过的。
- 交易经过节点验证通过后，会被广播至其对等节点（Peer Nodes），这些对等节点再将该交易广播给它们的对等节点，以此类推。一旦交易被广播至网络，会输出该交易的id，可以用它来追踪交易的状态。
- 交易先是被添加进交易池（有矿工维护），再由矿工进行评估选择来打包。矿工一般将所有交易存储在根据gasPrice价格分类的池中。
- 矿工选择将交易包含进区块，这些交易将被验证并包含进一个待处理区块，工作量证明开始。某个矿工节点最终会找到一个有效的区块，并将这一区块添加到区块链上。**就像上面介绍的节点广播原始交易一样，矿工节点也会将这一有效区块广播给其他节点。**
- 最终，全网节点将接收这个新区块，并同步区块链。一旦接收到这个新区块，节点就会执行区块里的所有交易。结合我们使用的truffle调用合约代码， truffle会不断测验连接节点的区块链以求确认。一旦它发现交易被确认，就会执行 then()中的回调逻辑。


### GHOST

- uncle reward


### 挖矿算法

- Ethash
Ethash工作量证明是内存难解的，这使它能抵抗ASIC。

### 难度调整

### 权益证明

### 智能合约

- 智能合约是运行在区块链上的一段代码，代码的逻辑定义合约的内容。具有图灵完备。智能合约的代码需要编译成bytecode，运行在EVM上。合约的代码放在data域。
- 智能合约的账户保存合约当前的运行状态。
- Solidity是智能合约最常用的语言。不支持多线程。
- 创建智能合约
外部账户发起一个转账交易到0x0地址，转账金额为0，智能合约代码放在data域中，但是要支付汽油费。矿工将智能合约发布到区块链上后，返回智能合约的地址。
- 调用智能合约
智能合约执行具有原子性，执行过程中出现错误会导致回滚。如果出现嵌套调用（一个合约调用另一个合约中的函数），不同的方式回滚策略不同。直接调用tansfer方式会导致连锁回滚，调用send方式只会返回false，不会导致连锁回滚，address类型的call方法调用也不会导致连锁回滚。
  - 外部账户
  创建一个交易，接收地址为要调用的智能合约的地址，data域填写要调用的函数（函数选择器）及参数的编码值。
  - 智能合约
    - 直接调用（transfer或者send）
    - address类型的call方法调用
    - fallback函数
- 重入攻击
- ERC20合约

### 汽油费

- 每个全节点需要独立对新区块中的交易做校验，所有交易在本地执行一遍，更新3棵树的内容，算出3个hash值，与发布区块中的3个hash值作比较。

### the Dao

### 美链


