### 事务

1. redis的事务是通过multi、exec、watch命令实现的。

2. 每一个RedisClient结构会有一个mstate属性来保存事务状态。mstate包含一个事务队列和一个已入队命令计数器。事务队列是一个multiCmd类型数组，每个multiCmd保存已入队命令信息。当客户端向服务器发送exec命令时，服务器会遍历客户端中的事务队列并执行所有命令。

3. watch是一个乐观锁实现，可以在exec执行前用来监视任意多个数据库键，在exec执行时检查是否至少一个键已经被修改，如果是，则拒绝事务执行并返回空回复。在每个Redis数据库（redisDb）中维护一个watched_keys字典，键是某个数据库键，值一个链表记录所有正在监视该键的客户端。当任何对数据库键做修改的命令执行后，会对watched_keys字典检查，看是否有客户端在监视该键，如果有，则会打开监视该键的客户端的REDIS_DIRTY_CAS标识，标识这个客户端的事务已被破坏。当该客户端向服务器执行exec时，服务器会检查客户端的REDIS_DIRTY_CAS标识，如果该标识已打开，则拒绝事务执行。

4. redis事务和ACID

   - 原子性

     redis事务队列中的命令要不全部执行，要不全部不执行，因为redis事务具有原子性。

     redis事务如果是在**命令入队过程中出错**，则会导致事务执行失败。但是redis和传统数据库的事务的区别在于redis事务没有回滚机制，如果是在**入队命令执行期间报错**，则并不会影响其他命令的执行结果。

   - 一致性

     （1）redis事务入队命令过程中，由于命令不存在或者命令格式错误导致事务执行失败，入队失败不会导致事务不一致。

     （2）事务命令执行过程中报错，不会影响到其余执行的命令的结果。

     （3）redis在无持久化，RDB，AOF模式下，redis服务器停机也不会影响事务一致性。

   - 隔离性

     redis使用单线程执行事务，并且服务器保证在事务执行过程中不会中断，因此redis事务总是串行执行的。

   - 持久性

     redis事务是通过redis当前的持久化模式实现的。如果redis当前采用无持久化，RDB，AOF（no、everysec）模式下，redis事务都不具有持久性，因为都有可能会有事务数据丢失。只有当AOF并且appendaof选项是always时才具有持久性（在打开no-appendfsync-on-rewrite选项情况下也不具有持久化，因为aof会被暂停，暂停期间也可能丢失事务数据）。