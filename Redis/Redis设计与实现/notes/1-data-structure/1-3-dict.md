### 字典
1. 字典在redis中的应用

   - 数据库底层使用字典实现
   - 哈希键底层实现

2. 字典的实现

   - redis字典使用哈希表底层实现。 哈希表结构包含table、size、sizemask、used等属性。
     1. table是一个数组，每个元素指向dictEntry（哈希表节点），每个dictEntry中保存一个KV对。哈希表节点结构包含key、value、next。key保存键值对的键，value保存值。next指向另一个哈希表节点。这个属性可以用来连接多个索引相同的节点，解决键冲突的问题。
     2. size表示哈希表的大小（数组大小）。
     3. sizemask总是等于size-1，sizemask和哈希值共同决定一个键的存放索引。
     4. used表示数组中已有的哈希表节点。
   - 字典结构包含type、privdata、ht[2]、rehashidx。
     1. type和privdata是针对不同类型的键值对使用的。redis会为不同用途不同类型的字典设置不同的类型特定函数。
     2. ht是一个大小为2的数组，每个元素指向一个哈希表结构。一般情况下只用第一个ht[0]。ht[1]  只有在rehash时会用到。
     3. rehashidx只有在rehash中才会用到，记录当前rehash的进度。

3. 哈希算法
   如果一个数n是2的幂次方，那么哈希值对其取模的等价于哈希值&(n-1)。

4. 解决键冲突
   redis底层的哈希表采用了单向链表解决键冲突问题。每次新节点会被添加到链表表头，复杂度为O(1)。因为没有指向链表表尾的指针，如果添加至表尾的话，每一次都需要从头部开始遍历，复杂度O(n)。

5. rehash

   - 扩展和收缩哈希表是通过rehash操作完成。rehash的流程：

     1. 为ht[1]哈希表分配空间，如果是扩展操作，ht[1]的空间为第一个大于等于ht[0].used*2的2的幂次方数。如果是收缩操作，ht[1]的空间为第一个大于等于ht[0].used的2的幂次方数。
     2. 将ht[0]中的所有节点rehash（重新计算哈希值和索引值）到ht[1]上面。
     3. 所有节点迁移完成后，释放ht[0]空间，将ht[1]设置为ht[0]，并在ht[1]新建空白哈希表，为下一次rehash准备。

   - 扩展和收缩的时机

     1. 服务端没有执行bgsave或者bgrewriteaof时，哈希表负载因子>=1自动执行扩展操作。
     2. 服务端正在执行bgsave或者bgrewriteaof时，哈希表负载因子>=5自动执行扩展操作。
     3. 当哈希表负载因子<0.1时，自动执行收缩操作。

   - 渐进式rehash

     redis服务器并不是一次性将ht[0]中的节点全部rehash到ht[1]中，而是分多次渐进式的rehash操作。为了避免当键值对数据量比较大时对服务器产生较大的性能影响。

     1. 为ht[1]分配空间，字典同时持有ht[0]、ht[1]，在字典结构中维持一个rehashidx，将值设置为0，表示rehash开始。在rehash期间，每次对字典增删改查操作，同时顺带会ht[0]中对应rehashidx位置的节点rehash到ht[1]中，完成后将rehashidx++。当所有的节点全部rehash完毕，将rehashidx设置为-1，表示rehash结束。
     2. 渐进式rehash的好处在于采用分而治之的方式，将rehash的工作量均摊到每次对字典的操作上，避免集中式rehash操作带来的性能问题。
     3. 在渐进式rehash期间，字典会同时使用ht[0]和ht[1]两个哈希表。字典的插入操作会一律直接保存到ht[1]中，而删除、修改、查询操作会先在ht[0]中进行，如果没找到，再继续到ht[1]中查找。这样可以保证ht[0]包含的节点数据最终会被全部迁移到ht[1]中。