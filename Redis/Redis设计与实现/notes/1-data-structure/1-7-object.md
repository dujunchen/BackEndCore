### 对象
1. redis并没有直接使用上面的数据结构来实现键值对数据库，而且基于这些数据结构创建了一个对象系统，每个对象使用了一种或多种数据结构。redis在执行命令之前，根据对象类型判断是否可以执行给定命令。
2. 使用对象的好处：
   - 同一个对象可以根据不同应用场景使用不同数据结构实现，优化不同场景下的效率。
   - redis针对对象实现引用计数技术的内存回收机制，并基于该机制实现了对象共享机制，多个数据库键可以通过同一个对象节约内存。
   - redis对象带有访问时间记录，可以计算数据库键的空转时长，启用maxmemory情况下，空转时长较大的键会被优先删除。

#### 对象类型和编码

1. redis键值对中，键和值都是一个对象。redis的键总是一个字符串对象，而值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象。

2. redis中每一个对象都是由一个redisObject结构表示。redisObject属性有以下属性：

   - type

     | 对象         | type的值     |
     | ------------ | ------------ |
     | 字符串对象   | REDIS_STRING |
     | 列表对象     | REDIS_LIST   |
     | 哈希对象     | REDIS_HASH   |
     | 集合对象     | REDIS_SET    |
     | 有序集合对象 | REDIS_ZSET   |

   - encoding

     对象使用的编码，也就是这个对象使用了什么数据结构。每种类型的对象都至少使用了两种不同编码。可以使用Object encoding命令查看。

     | 编码                      | 底层数据结构    |
     | ------------------------- | --------------- |
     | REDIS_ENCODING_INT        | long类型整数    |
     | REDIS_ENCODING_EMBSTR     | embstr编码的SDS |
     | REDIS_ENCODING_RAW        | SDS             |
     | REDIS_ENCODING_HT         | 字典            |
     | REDIS_ENCODING_LINKEDLIST | 双向链表        |
     | REDIS_ENCODING_ZIPLIST    | 压缩列表        |
     | REDIS_ENCODING_INTLIST    | 整数集合        |
     | REDIS_ENCODING_SKIPLIST   | 跳跃表和字典    |

     通过encoding属性设定对象使用的编码，而不是为特定类型对象关联特定编码，极大地提高redis的灵活性和效率。redis可以根据不同应用场景使用不同数据结构。

   - ptr

     指向对象底层实现的具体的数据结构，由encoding决定。

#### 字符串对象

1. 字符串对象的编码可以是int、raw、embstr。

   - 如果字符串对象保存的是一个可以用long表示的整数值，编码设置为int。

     ```
      127.0.0.1:6379> set num 10
     OK
      127.0.0.1:6379> OBJECT encoding num
     "int"
     ```

   - 字符串对象保存一个长度>32字节的字符串，编码设置为raw。

   - 字符串对象保存一个长度<=32字节的字符串，编码设置为embstr。

     embstr和raw的比较：

     - embstr和raw编码都使用redisObject和sdshdr结构表示字符串对象，但是raw会调用2次内存分配函数分别创建redisObject和sdshdr结构。embstr只会调用1次内存分配函数创建一块连续空间，依次包含redisObject和sdshdr结构。
     - 因为embstr所有数据保存在一块连续的内存上，能更好的的利用缓存的优势。

2. long double表示的浮点数在redis中也是作为字符串对象保存。在需要某些操作时，redis会先将字符串值转换成浮点值，在保存时再转回字符串值。

   ```
   127.0.0.1:6379> set pi 3.14
   OK
   127.0.0.1:6379> OBJECT encoding pi
   "embstr"
   127.0.0.1:6379> INCRBYFLOAT pi 10
   "13.14"
   127.0.0.1:6379> object encoding pi
   "embstr"
   ```

3. int编码和embstr编码在条件满足下可以转换成raw编码。

   - 只要让int编码的对象值不再是整数值，而是字符串值，就可以将对象的编码从int转为raw。
   - embstr编码的对象是一个只读的。当对embstr对象执行任何修改操作，都会导致embstr编码转为raw。

#### 列表对象

1. 列表对象的编码可以是ziplist、linkedlist。
   - ziplist底层用压缩列表实现。每个压缩节点entry保存一个列表元素。
   - linkedlist底层用双向列表实现。每个链表node保存一个字符串对象，而每个字符串对象中保存一个元素。
2. 编码转换

当同时满足以下两个条件，列表对象采用ziplist编码。

- 列表对象保存的所有字符串元素的长度都<64字节。可以通过list-max-ziplist-value修改。
- 列表对象保存的元素个数<512个。可以通过list-max-ziplist-entries修改。

如果以上条件未都满足，对象的编码会自动转成linkedlist，保存在压缩列表的元素也都会被转移保存到双向链表里。   

#### 哈希对象

1. 哈希对象编码可以是ziplist、hashtable。

   - ziplist底层采用压缩列表保存哈希对象的键值对。同一个键值对的两个压缩列表节点总是紧挨一起，保存键的节点在前，保存值得节点在后。先添加的键值对在压缩列表表头方向，后添加的在表尾方向。
   - hashtable采用字典保存哈希对象的键值对。字典的每个键都是字符串对象，字符串对象中保存键值对的键。字典的每个值都是字符串对象，字符串对象中保存键值对的值。

2. 编码转换

   当同时满足以下两个条件，哈希对象采用ziplist编码。

   - 哈希对象保存的键值对的键和值的字符串的长度都<64字节。可以通过hash-max-ziplist-value修改。
   - 哈希对象保存的键值对个数<512个。可以通过hash-max-ziplist-entries修改。

   如果以上条件未都满足，对象的编码会自动转成hashtable，保存在压缩列表的所有键值对也都会被转移保存到字典里。   

#### 集合

1. 集合对象编码可以是intset、hashtable。

   - intset底层采用整数集合实现。
   - hashtable底层采用字典实现。字典的每一个键都是一个字符串对象，保存一个集合元素，字典的所有值全部设置为NULL。

2. 编码转换

   当同时满足以下两个条件，集合对象采用intset编码。

   - 集合所有元素都是整数值。
   - 集合保存元素的数量不超过512个。可以通过set-max-intset-entries修改。

   如果以上条件未都满足，集合对象的编码会自动转成hashtable。

#### 有序集合

1. 有序集合的编码可以是ziplist、skiplist。

   - ziplist底层采用压缩列表实现。每个集合元素使用两个紧挨一起的压缩列表节点保存，第一个保存元素成员，第二个保存元素的分值。元素按照分值从小到大排序，分值小的放在表头方向，分值大的放在表尾方向。

   - skiplist底层采用zset结构实现。一个zset结构包含了一个字典结构dict和一个跳跃表zsl。跳跃表中按照分值从小到大保存了集合中所有元素。通过跳跃表可以对有序集合进行范围性操作。dict创建了一个成员和分值的映射。字典的键保存元素的成员，值保存了分值，通过这个字典可以用复杂度O(1)查找给定成员的分值。zset中的dict和zsl结构通过指针共享同一个元素的成员和分值，不会产生重复的成员和分值，浪费额外内存。

     zset同时采用dict和zsl结构实现的原因：如果仅通过字典实现，可以以复杂度O(1)查找成员的分值，而但是字典是无序的，在执行范围型操作时，比如zrank、zrange等，需要对元素排序，复杂度为O(NlogN)以及额外的O(N)的内存空间。仅通过跳跃表实现，范围型操作优势被保留，但是通过成员查找分值的复杂度为O(logN)。

     

2. 编码转换

   当同时满足以下两个条件，集合对象采用ziplist编码。

   - 有序集合的元素数量<128个。可以通过zset-max-ziplist-value修改。
   - 有序集合所有元素成员的长度都<64字节。可以通过zset-max-ziplist-entries修改。

   如果以上条件未都满足，有序集合对象的编码会自动转成skiplist。

#### 类型检查和多态命令

1. 类型检查

   redis操作命令分为2类：与对象类型无关的命令（如del、type、expire）和特定类型的命令（llen）。

   对于特定类型的命令，只能被特定类型的键执行，否则会报错。在执行一个类型特定命令前，redis会先检查输入键的类型是否正确，然后再决定是否执行该命令。类型特定命令的类型检查是通过redisObject结构中type属性实现的。比如执行LLEN操作前，会先检查输入的键的值对象redisObject结构的type属性是否是REDIS_LIST来决定是否执行或者返回一个类型错误。

```
127.0.0.1:6379> type msg
string
127.0.0.1:6379> LLEN msg
(error) WRONGTYPE Operation against a key holding the wrong kind of value
```

2. 多态命令

   redis会根据值对象的编码方式，选择正确的实现函数执行命令。比如列表对象的编码是ziplist，底层就采用压缩列表实现，调用压缩列表的函数。编码是linkedlist，就采用链表实现，调用双向链表的函数。

#### 内存回收和对象共享

1. redis底层采用引用计数技术实现内存回收机制。

2. redis的引用计数除了可以实现内存回收，还带有对象共享的作用。

   - redis对象共享步骤：

   （1）将数据库键的值指针指向一个现有的对象。

   （2）将被共享的值对象引用计数加一。

   - redis初始化服务器时会自动创建0到9999的所有整数值，当服务器需要使用这些值得字符串对象时，直接使用这些共享对象，而不会新创建对象。
   - redis可以使用Object refcount查看指定键的值对象的引用计数。
   - redis只对包含整数值的字符串对象进行共享，不共享包含字符串的字符串对象或者其他更复杂类型的对象（比如列表、集合等）。因为服务器将一个共享对象设置为键的值对象时，需要检查共享对象和键是否完全相同，只有完全相同才能共享。而一个共享对象保存的值越复杂，验证所需复杂度越高，cpu消耗也多。

#### 空转时长

1. RedisObject包含属性lru，记录了对象最后一次被命令访问的时间。可以使用object idletime打印键的空转时长，这个值时当前时间减去lru得到。
2. 如果启用maxmeory，并且采用内存回收策略是volatile-lru或者allkeys-lru，空转时长较高的会被优先回收。